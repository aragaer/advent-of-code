(load "common.scm")

(define *debug* #f)
(define *verbose* (and *debug* #f))

(define *elf-damage* 3)
(define *goblin-damage* 3)
(define *elf-hp* 200)
(define *goblin-hp* 200)
(define *original-elves* (make-hash-table))
(define *original-goblins* (make-hash-table))
(define *original-actors* '())
(define *this-round-actors* '())

(define (register-actor coord actor)
  (push! coord *original-actors*)
  actor)

(define (type->table type)
  (if (eq? type #:elf) *elves* *goblins*))

(define *width* 0)
(define *height* 0)

(define *original-map*
  (alist->hash-table
   (append-map (lambda (line y)
                 (set! *height* (max *height* y))
                 (map (lambda (char x)
                        (set! *width* (max *width* x))
                        (let ((coord (make-rectangular x y)))
                          (cons coord
                                (case char
                                  ((#\#) #:wall)
                                  ((#\.) #:space)
                                  ((#\E)
                                   (hash-table-set! *original-elves* coord *elf-hp*)
                                   (register-actor coord #:elf))
                                  ((#\G)
                                   (hash-table-set! *original-goblins* coord *goblin-hp*)
                                   (register-actor coord #:goblin))))))
                      (string->list line)
                      (range 0 1000)))
               (read-lines)
               (range 0 1000))))

(define *map* (hash-table-copy *original-map*))
(define *elves* (hash-table-copy *original-elves*))
(define *goblins* (hash-table-copy *original-goblins*))
(define *actors* (list-copy *original-actors*))
(inc! *height*)
(inc! *width*)

(define (spots-in-range coord)
  (filter (lambda (coord)
            (eq? (hash-table-ref *map* coord) #:space))
          (map (lambda (offt) (+ coord offt)) '(1 -1 +i -i))))

(define (complex-cmp n1 n2)
  (let ((x1 (real-part n1))
        (x2 (real-part n2))
        (y1 (imag-part n1))
        (y2 (imag-part n2)))
    (if (= y1 y2)
        (< x1 x2)
        (< y1 y2))))

(define ((in-range coord1) coord2)
  (member (- coord1 coord2) '(1 -1 +i -i)))

(define (wave-search from targets)
  (if (member from targets)
      (list from)
      (loop for layer = (spots-in-range from) then (lset-difference = (delete-duplicates (append-map spots-in-range layer)) prev)
            for prev = (list from) then (append layer prev)
            while (pair? layer)
            for reached-targets = (lset-intersection = layer targets)
            while (null? reached-targets)
            finally (return reached-targets))))

(define (remove-actor actor table)
  (hash-table-set! *map* actor #:space)
  (hash-table-delete! table actor)
  (set! *actors* (delete! actor *actors*))
  (set! *this-round-actors* (delete! actor *this-round-actors*)))

(define (move from to)
  (let* ((type (hash-table-ref *map* from))
         (my-table (type->table type))
         (my-hp (hash-table-ref my-table from)))
    (if *verbose*
        (print type " at " from " moves to " to))
    (remove-actor from my-table)
    (hash-table-set! *map* to type)
    (set! *actors* (cons to *actors*))
    (hash-table-set! my-table to my-hp)))

(define (attack attacker attacked)
  (let* ((attacker-type (hash-table-ref *map* attacker))
         (attacker-damage (if (eq? attacker-type #:elf) *elf-damage* *goblin-damage*))
         (attacked-type (hash-table-ref *map* attacked))
         (attacked-table (type->table attacked-type))
         (attacked-hp (hash-table-ref attacked-table attacked)))
    (if *verbose*
        (print attacker-type " at " attacker " attacks " attacked-type " at " attacked ": "
               attacked-hp " -> " (- attacked-hp attacker-damage)))
    (dec! attacked-hp attacker-damage)
    (if (>= 0 attacked-hp)
        (begin
          (if *debug*
              (print attacked-type " died at " attacked))
          (remove-actor attacked attacked-table))
        (hash-table-set! attacked-table attacked attacked-hp))))

(define (print-state)
  (loop for y in (range 0 *height*)
        do (loop for x in (range 0 *width*)
                 for coord = (make-rectangular x y)
                 with units = '()
                 with hps = '()
                 do (let* ((thing (hash-table-ref *map* coord))
                           (char (case thing
                                   ((#:space) #\.)
                                   ((#:wall) #\#)
                                   ((#:elf) #\E)
                                   ((#:goblin) #\G))))
                      (display char)
                      (when (or (eq? thing #:elf) (eq? thing #:goblin))
                        (push! char units)
                        (push! (hash-table-ref (type->table thing) coord) hps)))
                 finally (if (pair? units)
                           (format #t " ~{~{~a(~a)~}~^, ~}" (reverse (zip units hps)))))
        do (newline)))

(define ((hp-cmp table) unit1 unit2)
  (let ((hp1 (hash-table-ref table unit1))
        (hp2 (hash-table-ref table unit2)))
    (if (= hp1 hp2)
        (complex-cmp unit1 unit2)
        (< hp1 hp2))))

(define (turn unit opponents)
  (let ((type (hash-table-ref *map* unit))
        (opponents-in-range (filter (in-range unit) (hash-table-keys opponents))))
    (if *verbose* (print unit " acts"))
    (if (null? opponents-in-range)
        (let ((in-range-spots (delete-duplicates (append-map spots-in-range (hash-table-keys opponents)))))
          (when (pair? in-range-spots)
            (if *verbose*
                (print type " at " unit " can attack from following spots: " in-range-spots))
            (let ((reachable-spots (wave-search unit in-range-spots)))
              (if *verbose*
                  (print type " at " unit " can go to following spots: " reachable-spots))
              (when (pair? reachable-spots)
                (let* ((head-to-spot (first (sort reachable-spots complex-cmp)))
                       (step-to (first (sort (wave-search head-to-spot (spots-in-range unit)) complex-cmp))))
                  (move unit step-to)
                  (set! unit step-to)
                  (set! opponents-in-range (filter (in-range step-to) (hash-table-keys opponents)))))))))
    (if (pair? opponents-in-range)
        (attack unit (first (sort opponents-in-range (hp-cmp opponents)))))))

(if *debug* (print-state))

(loop for full-round-count from 0
      for this-round-idle-count = (length *actors*)
      do (set! *this-round-actors* (list-copy *actors*))
      do (loop while (pair? *this-round-actors*)
               for unit = (first (sort *this-round-actors* complex-cmp))
               for type = (hash-table-ref *map* unit)
               for opponents = (if (eq? type #:elf) *goblins* *elves*)
               until (null? (hash-table-keys opponents))
               do (set! *this-round-actors* (delete! unit *this-round-actors*))
               do (dec! this-round-idle-count)
               do (turn unit opponents))
      while (null? *this-round-actors*)
      if *verbose* do (print "after " (+ 1 full-round-count))
      if *verbose* do (print-state)
      finally (when *debug*
                (print "End:")
                (print "after " full-round-count)
                (print-state)
                (print (+ (reduce + 0 (hash-table-values *goblins*)))))
      finally (print (* full-round-count (+ (reduce + 0 (hash-table-values *elves*))
                                            (reduce + 0 (hash-table-values *goblins*))))))

(loop with elf-count = (hash-table-size *original-elves*)
      do (set! *map* (hash-table-copy *original-map*))
      do (set! *elves* (hash-table-copy *original-elves*))
      do (set! *goblins* (hash-table-copy *original-goblins*))
      do (set! *actors* (list-copy *original-actors*))
      until (loop for full-round-count from 0
                  for this-round-idle-count = (length *actors*)
                  do (set! *this-round-actors* (list-copy *actors*))
                  do (loop while (pair? *this-round-actors*)
                           for unit = (first (sort *this-round-actors* complex-cmp))
                           for type = (hash-table-ref *map* unit)
                           for opponents = (if (eq? type #:elf) *goblins* *elves*)
                           until (null? (hash-table-keys opponents))
                           do (set! *this-round-actors* (delete! unit *this-round-actors*))
                           do (dec! this-round-idle-count)
                           do (turn unit opponents))
                  while (null? *this-round-actors*)
                  while (= elf-count (hash-table-size *elves*))
                  if *verbose* do (print "after " (+ 1 full-round-count))
                  if *verbose* do (print-state)
                  if *verbose* do (print this-round-idle-count " actors were idle this round")
                  finally (if (= elf-count (hash-table-size *elves*))
                              (begin
                                (when *debug*
                                  (print "Elves win with power " *elf-damage*)
                                  (print "after " full-round-count)
                                  (print-state))
                                (print (* full-round-count (+ (reduce + 0 (hash-table-values *elves*))
                                                              (reduce + 0 (hash-table-values *goblins*)))))
                                (return #t))
                              (begin
                                (when *debug*
                                  (print "Elves lose with power " *elf-damage*)
                                  (print "after " full-round-count)
                                  (print-state))
                                (return #f))))
      do (inc! *elf-damage*))
